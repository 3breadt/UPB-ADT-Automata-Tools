\chapter{Reguläre Grammatik}

\section{Definition}

\subsection{Definition einer Grammatik}

Eine Grammatik G =(T,N,P,S) besteht aus:

\begin{tabular*}{1.0\textwidth}{l @{\extracolsep{\fill}} l}

T & einer Menge von Terminalsymbolen (kurz Terminalen)\\
N & einer Menge von Nichtterminalsymbolen (kurz Nichtterminale)\\
 & T und N sind disjunkte Mengen\\
 S $\in$ N & einem Startsymbol aus der Menge der Nichtterminale\\
 P $\subseteq$ N $\times$ V* & Menge der Produktionen; (A,x) $\in$ P, A $\in$ N
 und x $\in$ V*; \\
  & statt (A,x) schreibt man A $\rightarrow$ x\\
 V=T $\cup$ N & heißt Vokabular, seine Elemente heißen Symbole\\
 
\end{tabular*}

\subsection{Definition einer rechtslinearen Grammatik}

Eine Grammatik ist regulär wenn sie entweder eine rechtslineare Grammatik oder
eine linkslineare Grammatik ist.

Eine Grammatik G=G(T,N,P,S) ist einer rechtslineare Grammatik, wenn sie
folgenden Anforderungen genügt:

X $\rightarrow$ a Y \\
X $\rightarrow$ a \\
X $\rightarrow$ $\varepsilon$ \\
mit X,Y $\in$ N und a $\in$ T \\

\section{Datenstruktur}

\subsection{Implementation}

\begin{figure}[h]
  \begin{center}
  \includegraphics[scale=0.95]{objectsToInclude/UMLGrammar.pdf}
  \caption{Reguläre Grammatik UML Diagramm}
  \label{fig:UMLRegGrammar}
  \end{center}
\end{figure}

Die Klasse \textit{Grammar} besteht aus zwei \textit{dynArrays}
\textit{Terminals} und \textit{NonTerminals}, in diesen werden alle Terminal- und Nichtterminalsymbole
als String gespeichert, einem String \textit{Startsymbol} für das Startsymbol
der Grammatik, einer Integer Variablen isRegular, die angibt ob die Grammatik
regulär ist und einem weitern \textit{dynArray} \textit{Productions} für die
Produktionen. Die Template-Klasse \textit{dynArray} ermöglicht eine unbekannte
Anzahl von Variablen in einem Feld zu speichern, auf die Inhalte des Feldes
wird mit dem [ ]-Operator zugegriffen.

Produktionen bestehen aus einem Nichtterminal auf der linken Seite und eine
Substitution auf der rechten Seite des Pfeils. Die Klasse \textit{Production}
setzt sich aus einer Stringvariablen für die linke Seite und einer Klasse
Substitution für die rechte Seite zusammen.

Die Klasse \textit{Substitution} enthält eine Zeichenkette \textit{rawString}.
In dieser wird eine unbearbeitet Substitution abgespeichert, also zum Beispiel
direkt nach dem Einlesen, bevor diese dann weiter verarbeitet wird. In einem
\textit{dynArray} vom Typ \textit{flaggedString} wird dann die vollständig
verarbeitete Substitution ,unter dem Namen \textit{decodedSubstitution},
gespeichert. Der Struct \textit{flaggedString} setzt sich aus einem Integer,
der angibt ob das Symbol ein Terminal ist oder nicht und einem String, der das
Symbol speichert, zusammen. Die Funktion \textit{decode} wandelt nun den
\textit{rawString}, eine Folge von Terminalen und Nichtterminalen, in ein
flaggedString Array um, zur Weiterverarbeitung.

\section{Einlesen von regulären Grammatiken}

Es kann mittels der Klasse \textit{RGReaderWriter} eine Grammatik aus einer
Datei eingelesen oder in eine Datei geschrieben werden. Hinter einem Tag folgen die
zugehörigen Symbole. Das Einlesen erfolg zeichenweise.

\lstset{language=C, basicstyle=\footnotesize}
\begin{lstlisting}[float=h!, frame=tb, captionpos=b, caption={Beispiel zu
einem Textdatei der einen Grammatik darstellt.}, label=list:TextGrammar]
[Start]
<expression>
[Terminals]
a
b
c
d
[NonTerminals]
<expression>
[Productions]
<expression> --> a
<expression> --> b <expression>
<expression> --> a b <expression>
<expression> --> c d a b <expression>
<expression> --> d <expression>
\end{lstlisting}
 
\section{Konvertierungen von regulären Grammatiken}

Konvertierungen von einer regulären Grammatik zu einem endlichen Zustandsautomat
oder einem regulären Ausdruck sind nur möglich wenn die vorliegende Grammatik
regulär ist. Im Rahmen dieser Projektarbeit wurde eine rechtslinieare Grammatik gewählt.
(Siehe Definition einer rechtslinearen Grammatik).

\subsection{Konvertierung zu einem endlichen Zustandsautomaten}

Eine Transition vom Zustand A zum Zustand B mit a als Eingabe wird in einer
regulären Grammatik als '' A $\rightarrow$ a B `` gespeichert.
Um Zustand B als Endzustand zu setzen gibt es mehrere Möglichkeiten.

1.Fall:

\begin{tabular}{lcr}
B $\rightarrow$ a & $\Longrightarrow$ & B ist ein Endzustand\\
B $\rightarrow$ a B\\
\end{tabular}

Dieser Fall ist aber nicht genau so implementiert: Wird eine Produktion gefunden
wobei die rechte Seite nur ein Terminal ist, dann wird eine neue Endzustand
erzeugt (leztes Beispiel in Abbildung \ref{fig:convGrammar}). Diese Entscheidung
wurde getroffen damit nur eine Produktion pro Bearbeitung betrachtet werden
muss. Die zusätzlich erzeugten Zustände werden später entfernt durch die
Konvertierung des Automatens zu einem deterministischen, endlichen
Zustandsautomaten.

2.Fall:

\begin{tabular}{lcr}
B $\rightarrow$ $\varepsilon$ & $\Longrightarrow$ & B ist ein Endzustand\\
\end{tabular}

Ist ein Zustand in einer Transition sowohl Anfang als auch Ende wird dies durch
A $\rightarrow$ a A realisiert: eine Schleife.

\begin{figure}[h]
  \begin{center}
  \includegraphics[scale = 0.4]{objectsToInclude/convGram.jpg}
  \caption{Zusammenhang zwischen RG und FSA}
  \label{fig:convGrammar}
  \end{center}
\end{figure}

Für die Umwandlung werden die Produktionen der Reihe nach durchgegangen.
Es gibt 4 mögliche Produktionstypen:

1. A $\rightarrow$ $\varepsilon$ \\
2. A $\rightarrow$ a\\
3. A $\rightarrow$ a A\\
4. A $\rightarrow$ b A , wobei b eine Folge von Terminalen ist.\\

Es wird zuerst überprüft ob die linke Seite im Automaten schon als Zustand
vorhanden ist, falls nicht wird diese dem FSA hinzugefügt. Sollte diese das
Startsymbol sein wird der Zustand als Startzustand gespeichert. Ein Hilfspointer wird
auf diesen Zustand gesetzt.

Ist die rechte Seite das leere Symbol (Fall 1) wird der Zustand als final
markiert und die nächste Produktion umgewandelt, falls nicht wird jedes Symbol
der Substitution durchgegangen.

Ist das aktuelle Symbol ein Terminal und das letzte Symbol der Substitution(Fall 2)
wird ein Zustand Endstate erzeugt und eine Transition vom Hilfpointer zum Endstate
mit dem Terminal als Kante dem Automaten hinzugefügt. Der Endstate wird als
final markiert.

Ist das aktuelle Symbol ein Terminal, nicht das letzte Symbol und wird von einem
Nichtterminal gefolgt (Fall 3), wird das Nichtterminal, falls noch nicht vorhanden,
dem Automaten als Zustand hinzugefügt und eine Transition vom Hilfspointer zum
neuen Zustand mit dem Terminal als Kante erstellt.

Ist das aktuelle Symbol nicht das letzte Symbol, ein Terminal und wird von einem
weiteren Terminal(Fall4 )gefolgt, wird zunächst ein Hilfzustand erzeugt und eine
Transition vom Hilfspointer zum Hilfszustand mit dem Terminal als Kante
hinzugefügt. Der Hilfspointer wird auf den Hilfszustand gesetzt. Dieser Vorgang wird
solange wiederholt bis das aktuelle Symbol ein Terminal und das folgende Symbol ein
Nichtterminal ist. Dann wird, falls noch nicht vorhanden, ein Zustand des
Nichtterminals erzeugt und eine Transition vom Hilfspointer zum neuen Zustand mit
dem Terminal als Kante erstellt. Im Anschluss wird die nächste Produktion
verarbeitet.

\subsection{Konvertierung zu einem regulären Ausdrück}

Eine direkte Konvertierung von einer reguläre Grammatik zu einer regulären
Ausdrück ist im Rahmen dieses Projektes nicht implementiert. Diese Konvertierung
wird aber durch die Konvertierung einer Grammatik zu einem endlichen
Zustandsautomaten und schließlich zu einem regulären Ausdruck realisiert.

Eine direkte Umwandlung ist aber möglich. Die Idee ist im Folgenden dargestellt:
\subsubsection*{Die Grammatik in einer Kompaktform schreiben}
Alle Produktionen mit gleicher linker Seite werden zusammengefasst. z.B:

\begin{tabular}{lcr}

X $\rightarrow$ a Y & & \\
X $\rightarrow$ b Z & $\Longrightarrow$ & X $\rightarrow$ a Y | b Z
|$\varepsilon$\\
X $\rightarrow$ a $\varepsilon$ & &\\
 
\end{tabular}

\subsubsection*{Die Produktionen als gleichungen interpretieren}

Dafür werden die $\rightarrow$ zu ``=``  und die ``|'' zu ``+'' umgewandelt.
z.B:

\begin{tabular}{lcr}

X $\rightarrow$ a Y | b Z |$\varepsilon$ & $\Longrightarrow$ & X = a Y + b Z
+$\varepsilon$\\

 
\end{tabular}

\subsubsection*{Das Gleichungssystem lösen}

Gesucht ist eine Gleichung die nur das Startsymbol als Variable enthält.

Die Distributivität und Assoziation sind hier zwei verwendbare Eigenschaften der
gewönlischen ``+'' Operation. Zusätzlich, können Produktionen der Form A = c A +
B in die Form A = c* B umgewandelt werden.


\section{Minimierung eines endlichen Zustandsautomaten mittels den
Table-Filling-Algorithmus}

\subsection{Der Algorithmus}
\cite{minimization1,minimization2,minimization3}
Dieser Algorithmus ist abgeleitet vom Äquvalenzsatz von Myhill und Nerode. 

Es wird eine Matrix benötigt, in der in den Zeilen und Spalten alle Zustände des
Automaten vorhanden sind.

Die Grundidee ist, dass in dieser Matrix alle Paare von Zuständen markiert
werden die nicht äquivalent sind.

{\bf Formal: \\}
Seien P und Q zwei Zustände, $\omega$ ein Satz (eine Folge von Terminale), und X
= $\delta$(P,$\omega$) und Y = $\delta$(P,$\omega$) die nachfolgende Zustände von P und Q mit eingabe
$\omega$ .

P und Q sind zwei nicht-äquivalente Zustände, wenn ein Zustand vom
Zustandspaar (X,Y) ein akzeptierender Zustand und der Andere ein
nichtakzeptierender Zustand ist.

Falls für den Paar (P,Q) nicht entschieden werden kann ob die zwei Zustände
äquivalent sind oder nicht, werden die Zustände zu die Abhängigkeiten
(dependencies) der Nachfolgenden Zustände (X,Y) hinzugefügt. (P,Q) werden
später die Eigenschaft von (X,Y) haben.

%Workaround um Probleme mit UTF-8 und listings zu beheben
\lstset{language=C, basicstyle=\footnotesize}
\lstset{literate=%
{Ö}{{\"O}}1
{Ä}{{\"A}}1
{Ü}{{\"U}}1
{ß}{{\ss}}2
{ü}{{\"u}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
}
\begin{lstlisting}[float=h!, frame=tb, captionpos=b,
caption={Table-Filling-Algorithmus : Pseudocode}, label=list:TablefillingCode]
1.Initialisiere alle Paare in der Matrix als nicht-markiert,
 und ohne "dependencies".
2.Markiere alle Paare von akzeptierenden Zuständen und 
nicht-akzeptierenden Zuständen als nicht-äquvalent.
3.Für alle nicht markierte Paare (P,Q) und jedes Eingabesymbol a:
	Sei X = delta(P,a), Y = delta(Q,a).
	Falls (X,Y) nicht markiert, 
		füge (P,Q) zu den dependencies von (X,Y) hinzu,
	Sonst markiere (P,Q), und markiere alle dependencies von (P,Q).
	
\end{lstlisting}

\subsection{Implementierung}
\cite{minimization4,minimization5}
Um diesen Algorithmus zu impelementieren, wurde eine neue Klasse
\textit{TableFillingMinimizer} erstellt. Diese Klasse bietet die benötigten
Methoden um einen endlichen Zustandsautomat zu minimieren.

\begin{figure}[h]
  \begin{center}
  \includegraphics{objectsToInclude/TableFillingMinimizer.pdf}
  \caption{UML Diagramm zu \textit{TableFillingMinimizer}}
  \label{fig:UMLminTable}
  \end{center}
\end{figure}

Die verwendete Matrix in diesem Algorithmus ist eine Matrix von
\textit{StatesPair}, wobei jedes \textit{StatesPair} eine Struktur ist in der
gespeichert wird ob ein Paar nicht-äquivalent ist, und eine Liste mit den
Abhängigkeiten dieses Paares.
